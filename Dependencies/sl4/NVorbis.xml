<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NVorbis</name>
    </assembly>
    <members>
        <member name="T:NVorbis.DataPacket">
            <summary>
            A single data packet from a logical Vorbis stream.
            </summary>
        </member>
        <member name="T:NVorbis.DataPacket.PacketFlags">
            <summary>
            Defines flags to apply to the current packet
            </summary>
        </member>
        <member name="F:NVorbis.DataPacket.PacketFlags.IsResync">
            <summary>
            Packet is first since reader had to resync with stream.
            </summary>
        </member>
        <member name="F:NVorbis.DataPacket.PacketFlags.IsEndOfStream">
            <summary>
            Packet is the last in the logical stream.
            </summary>
        </member>
        <member name="F:NVorbis.DataPacket.PacketFlags.IsShort">
            <summary>
            Packet does not have all its data available.
            </summary>
        </member>
        <member name="F:NVorbis.DataPacket.PacketFlags.HasGranuleCount">
            <summary>
            Packet has a granule count defined.
            </summary>
        </member>
        <member name="F:NVorbis.DataPacket.PacketFlags.User1">
            <summary>
            Flag for use by inheritors.
            </summary>
        </member>
        <member name="F:NVorbis.DataPacket.PacketFlags.User2">
            <summary>
            Flag for use by inheritors.
            </summary>
        </member>
        <member name="F:NVorbis.DataPacket.PacketFlags.User3">
            <summary>
            Flag for use by inheritors.
            </summary>
        </member>
        <member name="F:NVorbis.DataPacket.PacketFlags.User4">
            <summary>
            Flag for use by inheritors.
            </summary>
        </member>
        <member name="M:NVorbis.DataPacket.GetFlag(NVorbis.DataPacket.PacketFlags)">
            <summary>
            Gets the value of the specified flag.
            </summary>
        </member>
        <member name="M:NVorbis.DataPacket.SetFlag(NVorbis.DataPacket.PacketFlags,System.Boolean)">
            <summary>
            Sets the value of the specified flag.
            </summary>
        </member>
        <member name="M:NVorbis.DataPacket.#ctor(System.Int32)">
            <summary>
            Creates a new instance with the specified length.
            </summary>
            <param name="length">The length of the packet.</param>
        </member>
        <member name="M:NVorbis.DataPacket.ReadNextByte">
            <summary>
            Reads the next byte of the packet.
            </summary>
            <returns>The next byte if available, otherwise -1.</returns>
        </member>
        <member name="M:NVorbis.DataPacket.Done">
            <summary>
            Indicates that the packet has been read and its data is no longer needed.
            </summary>
        </member>
        <member name="M:NVorbis.DataPacket.TryPeekBits(System.Int32,System.Int32@)">
            <summary>
            Attempts to read the specified number of bits from the packet, but may return fewer.  Does not advance the position counter.
            </summary>
            <param name="count">The number of bits to attempt to read.</param>
            <param name="bitsRead">The number of bits actually read.</param>
            <returns>The value of the bits read.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is not between 0 and 64.</exception>
        </member>
        <member name="M:NVorbis.DataPacket.SkipBits(System.Int32)">
            <summary>
            Advances the position counter by the specified number of bits.
            </summary>
            <param name="count">The number of bits to advance.</param>
        </member>
        <member name="M:NVorbis.DataPacket.ResetBitReader">
            <summary>
            Resets the bit reader.
            </summary>
        </member>
        <member name="P:NVorbis.DataPacket.IsResync">
            <summary>
            Gets whether the packet was found after a stream resync.
            </summary>
        </member>
        <member name="P:NVorbis.DataPacket.GranulePosition">
            <summary>
            Gets the position of the last granule in the packet.
            </summary>
        </member>
        <member name="P:NVorbis.DataPacket.PageGranulePosition">
            <summary>
            Gets the position of the last granule in the page the packet is in.
            </summary>
        </member>
        <member name="P:NVorbis.DataPacket.Length">
            <summary>
            Gets the length of the packet.
            </summary>
        </member>
        <member name="P:NVorbis.DataPacket.IsEndOfStream">
            <summary>
            Gets whether the packet is the last one in the logical stream.
            </summary>
        </member>
        <member name="P:NVorbis.DataPacket.BitsRead">
            <summary>
            Gets the number of bits read from the packet.
            </summary>
        </member>
        <member name="P:NVorbis.DataPacket.GranuleCount">
            <summary>
            Gets the number of granules in the packet.  If <c>null</c>, the packet has not been decoded yet.
            </summary>
        </member>
        <member name="M:NVorbis.DataPacket.ReadBits(System.Int32)">
            <summary>
            Reads the specified number of bits from the packet and advances the position counter.
            </summary>
            <param name="count">The number of bits to read.</param>
            <returns>The value of the bits read.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The number of bits specified is not between 0 and 64.</exception>
        </member>
        <member name="M:NVorbis.DataPacket.PeekByte">
            <summary>
            Reads the next byte from the packet.  Does not advance the position counter.
            </summary>
            <returns>The byte read from the packet.</returns>
        </member>
        <member name="M:NVorbis.DataPacket.ReadByte">
            <summary>
            Reads the next byte from the packet and advances the position counter.
            </summary>
            <returns>The byte read from the packet.</returns>
        </member>
        <member name="M:NVorbis.DataPacket.ReadBytes(System.Int32)">
            <summary>
            Reads the specified number of bytes from the packet and advances the position counter.
            </summary>
            <param name="count">The number of bytes to read.</param>
            <returns>A byte array holding the data read.</returns>
        </member>
        <member name="M:NVorbis.DataPacket.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the specified number of bytes from the packet into the buffer specified and advances the position counter.
            </summary>
            <param name="buffer">The buffer to read into.</param>
            <param name="index">The index into the buffer to start placing the read data.</param>
            <param name="count">The number of bytes to read.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than 0 or <paramref name="index"/> + <paramref name="count"/> is past the end of <paramref name="buffer"/>.</exception>
        </member>
        <member name="M:NVorbis.DataPacket.ReadBit">
            <summary>
            Reads the next bit from the packet and advances the position counter.
            </summary>
            <returns>The value of the bit read.</returns>
        </member>
        <member name="M:NVorbis.DataPacket.ReadInt16">
            <summary>
            Retrieves the next 16 bits from the packet as a <see cref="T:System.Int16"/> and advances the position counter.
            </summary>
            <returns>The value of the next 16 bits.</returns>
        </member>
        <member name="M:NVorbis.DataPacket.ReadInt32">
            <summary>
            Retrieves the next 32 bits from the packet as a <see cref="T:System.Int32"/> and advances the position counter.
            </summary>
            <returns>The value of the next 32 bits.</returns>
        </member>
        <member name="M:NVorbis.DataPacket.ReadInt64">
            <summary>
            Retrieves the next 64 bits from the packet as a <see cref="T:System.Int64"/> and advances the position counter.
            </summary>
            <returns>The value of the next 64 bits.</returns>
        </member>
        <member name="M:NVorbis.DataPacket.ReadUInt16">
            <summary>
            Retrieves the next 16 bits from the packet as a <see cref="T:System.UInt16"/> and advances the position counter.
            </summary>
            <returns>The value of the next 16 bits.</returns>
        </member>
        <member name="M:NVorbis.DataPacket.ReadUInt32">
            <summary>
            Retrieves the next 32 bits from the packet as a <see cref="T:System.UInt32"/> and advances the position counter.
            </summary>
            <returns>The value of the next 32 bits.</returns>
        </member>
        <member name="M:NVorbis.DataPacket.ReadUInt64">
            <summary>
            Retrieves the next 64 bits from the packet as a <see cref="T:System.UInt64"/> and advances the position counter.
            </summary>
            <returns>The value of the next 64 bits.</returns>
        </member>
        <member name="M:NVorbis.DataPacket.SkipBytes(System.Int32)">
            <summary>
            Advances the position counter by the specified number of bytes.
            </summary>
            <param name="count">The number of bytes to advance.</param>
        </member>
        <member name="T:NVorbis.IContainerReader">
            <summary>
            Provides a interface for a Vorbis logical stream container.
            </summary>
        </member>
        <member name="P:NVorbis.IContainerReader.StreamSerials">
            <summary>
            Gets the list of stream serials found in the container so far.
            </summary>
        </member>
        <member name="P:NVorbis.IContainerReader.CanSeek">
            <summary>
            Gets whether the container supports seeking.
            </summary>
        </member>
        <member name="P:NVorbis.IContainerReader.WasteBits">
            <summary>
            Gets the number of bits in the container that are not associated with a logical stream.
            </summary>
        </member>
        <member name="P:NVorbis.IContainerReader.PagesRead">
            <summary>
            Gets the number of pages that have been read in the container.
            </summary>
        </member>
        <member name="E:NVorbis.IContainerReader.NewStream">
            <summary>
            Event raised when a new logical stream is found in the container.
            </summary>
        </member>
        <member name="M:NVorbis.IContainerReader.Init">
            <summary>
            Initializes the container and finds the first stream.
            </summary>
            <returns><c>True</c> if a valid logical stream is found, otherwise <c>False</c>.</returns>
        </member>
        <member name="M:NVorbis.IContainerReader.FindNextStream">
            <summary>
            Finds the next new stream in the container.
            </summary>
            <returns><c>True</c> if a new stream was found, otherwise <c>False</c>.</returns>
            <exception cref="T:System.InvalidOperationException"><see cref="P:NVorbis.IContainerReader.CanSeek"/> is <c>False</c>.</exception>
        </member>
        <member name="M:NVorbis.IContainerReader.GetTotalPageCount">
            <summary>
            Retrieves the total number of pages in the container.
            </summary>
            <returns>The total number of pages.</returns>
            <exception cref="T:System.InvalidOperationException"><see cref="P:NVorbis.IContainerReader.CanSeek"/> is <c>False</c>.</exception>
        </member>
        <member name="T:NVorbis.IPacketProvider">
            <summary>
            Provides packets on-demand for the Vorbis stream decoder.
            </summary>
        </member>
        <member name="P:NVorbis.IPacketProvider.StreamSerial">
            <summary>
            Gets the serial number associated with this stream.
            </summary>
        </member>
        <member name="P:NVorbis.IPacketProvider.CanSeek">
            <summary>
            Gets whether seeking is supported on this stream.
            </summary>
        </member>
        <member name="P:NVorbis.IPacketProvider.ContainerBits">
            <summary>
            Gets the number of bits of overhead in this stream's container.
            </summary>
        </member>
        <member name="M:NVorbis.IPacketProvider.GetTotalPageCount">
            <summary>
            Retrieves the total number of pages (or frames) this stream uses.
            </summary>
            <returns>The page count.</returns>
            <exception cref="T:System.InvalidOperationException"><see cref="P:NVorbis.IPacketProvider.CanSeek"/> is <c>False</c>.</exception>
        </member>
        <member name="M:NVorbis.IPacketProvider.GetNextPacket">
            <summary>
            Retrieves the next packet in the stream.
            </summary>
            <returns>The next packet in the stream or <c>null</c> if no more packets.</returns>
        </member>
        <member name="M:NVorbis.IPacketProvider.PeekNextPacket">
            <summary>
            Retrieves the next packet in the stream but does not advance to the following packet.
            </summary>
            <returns>The next packet in the stream or <c>null</c> if no more packets.</returns>
        </member>
        <member name="M:NVorbis.IPacketProvider.GetPacket(System.Int32)">
            <summary>
            Retrieves the packet specified from the stream.
            </summary>
            <param name="packetIndex">The index of the packet to retrieve.</param>
            <returns>The specified packet.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="packetIndex"/> is less than 0 or past the end of the stream.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:NVorbis.IPacketProvider.CanSeek"/> is <c>False</c>.</exception>
        </member>
        <member name="M:NVorbis.IPacketProvider.GetGranuleCount">
            <summary>
            Retrieves the total number of granules in this Vorbis stream.
            </summary>
            <returns>The number of samples</returns>
            <exception cref="T:System.InvalidOperationException"><see cref="P:NVorbis.IPacketProvider.CanSeek"/> is <c>False</c>.</exception>
        </member>
        <member name="M:NVorbis.IPacketProvider.FindPacket(System.Int64,System.Func{NVorbis.DataPacket,NVorbis.DataPacket,System.Int32})">
            <summary>
            Finds the packet index to the granule position specified in the current stream.
            </summary>
            <param name="granulePos">The granule position to seek to.</param>
            <param name="packetGranuleCountCallback">A callback method that takes the current and previous packets and returns the number of granules in the current packet.</param>
            <returns>The index of the packet that includes the specified granule position or -1 if none found.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="granulePos"/> is less than 0 or is after the last granule.</exception>
        </member>
        <member name="M:NVorbis.IPacketProvider.SeekToPacket(NVorbis.DataPacket,System.Int32)">
            <summary>
            Sets the next packet to be returned, applying a pre-roll as necessary.
            </summary>
            <param name="packet">The packet to key from.</param>
            <param name="preRoll">The number of packets to return before the indicated packet.</param>
        </member>
        <member name="E:NVorbis.IPacketProvider.ParameterChange">
            <summary>
            Occurs when the stream is about to change parameters.
            </summary>
        </member>
        <member name="M:NVorbis.IVorbisStreamStatus.ResetStats">
            <summary>
            Gets the counters for latency and bitrate calculations, as well as overall bit counts
            </summary>
        </member>
        <member name="P:NVorbis.IVorbisStreamStatus.EffectiveBitRate">
            <summary>
            Gets the calculated bit rate of audio stream data for the everything decoded so far
            </summary>
        </member>
        <member name="P:NVorbis.IVorbisStreamStatus.InstantBitRate">
            <summary>
            Gets the calculated bit rate for the last ~1 second of audio
            </summary>
        </member>
        <member name="P:NVorbis.IVorbisStreamStatus.PageLatency">
            <summary>
            Gets the calculated latency per page
            </summary>
        </member>
        <member name="P:NVorbis.IVorbisStreamStatus.PacketLatency">
            <summary>
            Gets the calculated latency per packet
            </summary>
        </member>
        <member name="P:NVorbis.IVorbisStreamStatus.SecondLatency">
            <summary>
            Gets the calculated latency per second of output
            </summary>
        </member>
        <member name="P:NVorbis.IVorbisStreamStatus.OverheadBits">
            <summary>
            Gets the number of bits read that do not contribute to the output audio
            </summary>
        </member>
        <member name="P:NVorbis.IVorbisStreamStatus.AudioBits">
            <summary>
            Gets the number of bits read that contribute to the output audio
            </summary>
        </member>
        <member name="P:NVorbis.IVorbisStreamStatus.PagesRead">
            <summary>
            Gets the number of pages read so far in the current stream
            </summary>
        </member>
        <member name="P:NVorbis.IVorbisStreamStatus.TotalPages">
            <summary>
            Gets the total number of pages in the current stream
            </summary>
        </member>
        <member name="P:NVorbis.IVorbisStreamStatus.Clipped">
            <summary>
            Gets whether the stream has been clipped since the last reset
            </summary>
        </member>
        <member name="T:NVorbis.NewStreamEventArgs">
            <summary>
            Event data for when a new logical stream is found in a container.
            </summary>
        </member>
        <member name="M:NVorbis.NewStreamEventArgs.#ctor(NVorbis.IPacketProvider)">
            <summary>
            Creates a new instance of <see cref="T:NVorbis.NewStreamEventArgs"/> with the specified <see cref="T:NVorbis.IPacketProvider"/>.
            </summary>
            <param name="packetProvider">An <see cref="T:NVorbis.IPacketProvider"/> instance.</param>
        </member>
        <member name="P:NVorbis.NewStreamEventArgs.PacketProvider">
            <summary>
            Gets new the <see cref="T:NVorbis.IPacketProvider"/> instance.
            </summary>
        </member>
        <member name="P:NVorbis.NewStreamEventArgs.IgnoreStream">
            <summary>
            Gets or sets whether to ignore the logical stream associated with the packet provider.
            </summary>
        </member>
        <member name="T:NVorbis.Ogg.LightContainerReader">
            <summary>
            Implements <see cref="T:NVorbis.IContainerReader"/> for Ogg format files for low memory cost.
            </summary>
        </member>
        <member name="P:NVorbis.Ogg.LightContainerReader.StreamSerials">
            <summary>
            Gets the list of stream serials found in the container so far.
            </summary>
        </member>
        <member name="P:NVorbis.Ogg.LightContainerReader.CanSeek">
            <summary>
            Gets whether the container supports seeking.
            </summary>
        </member>
        <member name="P:NVorbis.Ogg.LightContainerReader.WasteBits">
            <summary>
            Gets the number of bits in the container that are not associated with a logical stream.
            </summary>
        </member>
        <member name="P:NVorbis.Ogg.LightContainerReader.PagesRead">
            <summary>
            Gets the number of pages that have been read in the container.
            </summary>
        </member>
        <member name="E:NVorbis.Ogg.LightContainerReader.NewStream">
            <summary>
            Event raised when a new logical stream is found in the container.
            </summary>
        </member>
        <member name="M:NVorbis.Ogg.LightContainerReader.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Creates a new instance of <see cref="T:NVorbis.Ogg.LightContainerReader"/>.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to read.</param>
            <param name="closeOnDispose"><c>True</c> to close the stream when disposed, otherwise <c>false</c>.</param>
            <exception cref="T:System.ArgumentException"><paramref name="stream"/>'s <see cref="P:System.IO.Stream.CanSeek"/> is <c>False</c>.</exception>
        </member>
        <member name="M:NVorbis.Ogg.LightContainerReader.Init">
            <summary>
            Initializes the container and finds the first stream.
            </summary>
            <returns><c>True</c> if a valid logical stream is found, otherwise <c>False</c>.</returns>
        </member>
        <member name="M:NVorbis.Ogg.LightContainerReader.FindNextStream">
            <summary>
            Finds the next new stream in the container.
            </summary>
            <returns><c>True</c> if a new stream was found, otherwise <c>False</c>.</returns>
        </member>
        <member name="M:NVorbis.Ogg.LightContainerReader.GetTotalPageCount">
            <summary>
            Retrieves the total number of pages in the container.
            </summary>
            <returns>The total number of pages.</returns>
        </member>
        <member name="M:NVorbis.Ogg.LightContainerReader.Dispose">
            <summary>
            Cleans up
            </summary>
        </member>
        <member name="T:NVorbis.Ogg.ContainerReader">
            <summary>
            Provides an <see cref="T:NVorbis.IContainerReader"/> implementation for basic Ogg files.
            </summary>
        </member>
        <member name="P:NVorbis.Ogg.ContainerReader.StreamSerials">
            <summary>
            Gets the list of stream serials found in the container so far.
            </summary>
        </member>
        <member name="E:NVorbis.Ogg.ContainerReader.NewStream">
            <summary>
            Event raised when a new logical stream is found in the container.
            </summary>
        </member>
        <member name="M:NVorbis.Ogg.ContainerReader.#ctor(System.String)">
            <summary>
            Creates a new instance with the specified file.
            </summary>
            <param name="path">The full path to the file.</param>
        </member>
        <member name="M:NVorbis.Ogg.ContainerReader.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Creates a new instance with the specified stream.  Optionally sets to close the stream when disposed.
            </summary>
            <param name="stream">The stream to read.</param>
            <param name="closeOnDispose"><c>True</c> to close the stream when <see cref="M:NVorbis.Ogg.ContainerReader.Dispose"/> is called, otherwise <c>False</c>.</param>
        </member>
        <member name="M:NVorbis.Ogg.ContainerReader.Init">
            <summary>
            Initializes the container and finds the first stream.
            </summary>
            <returns><c>True</c> if a valid logical stream is found, otherwise <c>False</c>.</returns>
        </member>
        <member name="M:NVorbis.Ogg.ContainerReader.Dispose">
            <summary>
            Disposes this instance.
            </summary>
        </member>
        <member name="M:NVorbis.Ogg.ContainerReader.GetStream(System.Int32)">
            <summary>
            Gets the <see cref="T:NVorbis.IPacketProvider"/> instance for the specified stream serial.
            </summary>
            <param name="streamSerial">The stream serial to look for.</param>
            <returns>An <see cref="T:NVorbis.IPacketProvider"/> instance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified stream serial was not found.</exception>
        </member>
        <member name="M:NVorbis.Ogg.ContainerReader.FindNextStream">
            <summary>
            Finds the next new stream in the container.
            </summary>
            <returns><c>True</c> if a new stream was found, otherwise <c>False</c>.</returns>
        </member>
        <member name="P:NVorbis.Ogg.ContainerReader.PagesRead">
            <summary>
            Gets the number of pages that have been read in the container.
            </summary>
        </member>
        <member name="M:NVorbis.Ogg.ContainerReader.GetTotalPageCount">
            <summary>
            Retrieves the total number of pages in the container.
            </summary>
            <returns>The total number of pages.</returns>
        </member>
        <member name="P:NVorbis.Ogg.ContainerReader.CanSeek">
            <summary>
            Gets whether the container supports seeking.
            </summary>
        </member>
        <member name="P:NVorbis.Ogg.ContainerReader.WasteBits">
            <summary>
            Gets the number of bits in the container that are not associated with a logical stream.
            </summary>
        </member>
        <member name="T:NVorbis.ParameterChangeEventArgs">
            <summary>
            Event data for when a logical stream has a parameter change.
            </summary>
        </member>
        <member name="M:NVorbis.ParameterChangeEventArgs.#ctor(NVorbis.DataPacket)">
            <summary>
            Creates a new instance of <see cref="T:NVorbis.ParameterChangeEventArgs"/>.
            </summary>
            <param name="firstPacket">The first packet after the parameter change.</param>
        </member>
        <member name="P:NVorbis.ParameterChangeEventArgs.FirstPacket">
            <summary>
            Gets the first packet after the parameter change.  This would typically be the parameters packet.
            </summary>
        </member>
        <member name="P:NVorbis.VorbisReader.Channels">
            <summary>
            Gets the number of channels in the current selected Vorbis stream
            </summary>
        </member>
        <member name="P:NVorbis.VorbisReader.SampleRate">
            <summary>
            Gets the sample rate of the current selected Vorbis stream
            </summary>
        </member>
        <member name="P:NVorbis.VorbisReader.UpperBitrate">
            <summary>
            Gets the encoder's upper bitrate of the current selected Vorbis stream
            </summary>
        </member>
        <member name="P:NVorbis.VorbisReader.NominalBitrate">
            <summary>
            Gets the encoder's nominal bitrate of the current selected Vorbis stream
            </summary>
        </member>
        <member name="P:NVorbis.VorbisReader.LowerBitrate">
            <summary>
            Gets the encoder's lower bitrate of the current selected Vorbis stream
            </summary>
        </member>
        <member name="P:NVorbis.VorbisReader.Vendor">
            <summary>
            Gets the encoder's vendor string for the current selected Vorbis stream
            </summary>
        </member>
        <member name="P:NVorbis.VorbisReader.Comments">
            <summary>
            Gets the comments in the current selected Vorbis stream
            </summary>
        </member>
        <member name="P:NVorbis.VorbisReader.IsParameterChange">
            <summary>
            Gets whether the previous short sample count was due to a parameter change in the stream.
            </summary>
        </member>
        <member name="P:NVorbis.VorbisReader.ContainerOverheadBits">
            <summary>
            Gets the number of bits read that are related to framing and transport alone
            </summary>
        </member>
        <member name="P:NVorbis.VorbisReader.ClipSamples">
            <summary>
            Gets or sets whether to automatically apply clipping to samples returned by <see cref="M:NVorbis.VorbisReader.ReadSamples(System.Single[],System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="P:NVorbis.VorbisReader.Stats">
            <summary>
            Gets stats from each decoder stream available
            </summary>
        </member>
        <member name="P:NVorbis.VorbisReader.StreamIndex">
            <summary>
            Gets the currently-selected stream's index
            </summary>
        </member>
        <member name="M:NVorbis.VorbisReader.ReadSamples(System.Single[],System.Int32,System.Int32)">
            <summary>
            Reads decoded samples from the current logical stream
            </summary>
            <param name="buffer">The buffer to write the samples to</param>
            <param name="offset">The offset into the buffer to write the samples to</param>
            <param name="count">The number of samples to write</param>
            <returns>The number of samples written</returns>
        </member>
        <member name="M:NVorbis.VorbisReader.ClearParameterChange">
            <summary>
            Clears the parameter change flag so further samples can be requested.
            </summary>
        </member>
        <member name="P:NVorbis.VorbisReader.StreamCount">
            <summary>
            Returns the number of logical streams found so far in the physical container
            </summary>
        </member>
        <member name="M:NVorbis.VorbisReader.FindNextStream">
            <summary>
            Searches for the next stream in a concatenated file
            </summary>
            <returns><c>True</c> if a new stream was found, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NVorbis.VorbisReader.SwitchStreams(System.Int32)">
            <summary>
            Switches to an alternate logical stream.
            </summary>
            <param name="index">The logical stream index to switch to</param>
            <returns><c>True</c> if the properties of the logical stream differ from those of the one previously being decoded. Otherwise, <c>False</c>.</returns>
        </member>
        <member name="P:NVorbis.VorbisReader.DecodedTime">
            <summary>
            Gets or Sets the current timestamp of the decoder.  Is the timestamp before the next sample to be decoded
            </summary>
        </member>
        <member name="P:NVorbis.VorbisReader.DecodedPosition">
            <summary>
            Gets or Sets the current position of the next sample to be decoded.
            </summary>
        </member>
        <member name="P:NVorbis.VorbisReader.TotalTime">
            <summary>
            Gets the total length of the current logical stream
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:System.Collections.Generic.HashSet`1" -->
        <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Implementation Notes:
            Since resizes are relatively expensive (require rehashing), this attempts to minimize 
            the need to resize by setting the initial capacity based on size of collection. 
            </summary>
            <param name="collection"></param>
            <param name="comparer"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection{T}#Add(`0)" -->
        <member name="M:System.Collections.Generic.HashSet`1.Clear">
            <summary>
            Remove all items from this set. This clears the elements but not the underlying 
            buckets and slots array. Follow this call by TrimExcess to release these.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Contains(`0)">
            <summary>
            Checks if this hashset contains the item
            </summary>
            <param name="item">item to check for containment</param>
            <returns>true if item contained; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy items in this hashset to array, starting at arrayIndex
            </summary>
            <param name="array">array to add items to</param>
            <param name="arrayIndex">index to start at</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Remove(`0)">
            <summary>
            Remove item from this hashset
            </summary>
            <param name="item">item to remove</param>
            <returns>true if removed; false if not (i.e. if the item wasn't in the HashSet)</returns>
        </member>
        <member name="P:System.Collections.Generic.HashSet`1.Count">
            <summary>
            Number of elements in this hashset
            </summary>
        </member>
        <member name="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Whether this is readonly
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Add(`0)">
            <summary>
            Add item to this HashSet. Returns bool indicating whether item was added (won't be 
            added if already present)
            </summary>
            <param name="item"></param>
            <returns>true if added, false if already present</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)">
            <summary>
            Searches the set for a given value and returns the equal value it finds, if any.
            </summary>
            <param name="equalValue">The value to search for.</param>
            <param name="actualValue">The value from the set that the search found, or the default value of <typeparamref name="T"/> when the search yielded no match.</param>
            <returns>A value indicating whether the search was successful.</returns>
            <remarks>
            This can be useful when you want to reuse a previously stored reference instead of 
            a newly constructed one (so that more sharing of references can occur) or to look up
            a value that has more complete data than the value you currently have, although their
            comparer functions indicate they are equal.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Take the union of this HashSet with other. Modifies this set.
            
            Implementation note: GetSuggestedCapacity (to increase capacity in advance avoiding 
            multiple resizes ended up not being useful in practice; quickly gets to the 
            point where it's a wasteful check.
            </summary>
            <param name="other">enumerable with items to add</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove items in other from this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to remove</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a superset of other
            
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If other has no elements (it's the empty set), then this is a superset, even if this
            is also the empty set.
            2. If other has unique elements according to this equality comparer, and this has less 
            than the number of elements in other, then this can't be a superset
            
            </summary>
            <param name="other"></param>
            <returns>true if this is a superset of other; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this set overlaps other (i.e. they share at least one item)
            </summary>
            <param name="other"></param>
            <returns>true if these have at least one common element; false if disjoint</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
            <summary>
            Remove elements that match specified predicate. Returns the number of elements removed
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="P:System.Collections.Generic.HashSet`1.Comparer">
            <summary>
            Gets the IEqualityComparer that is used to determine equality of keys for 
            the HashSet.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.TrimExcess">
            <summary>
            Sets the capacity of this list to the size of the list (rounded up to nearest prime),
            unless count is 0, in which case we release references.
            
            This method can be used to minimize a list's memory overhead once it is known that no
            new elements will be added to the list. To completely clear a list and release all 
            memory referenced by the list, execute the following statements:
            
            list.Clear();
            list.TrimExcess(); 
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Initialize(System.Int32)">
            <summary>
            Initializes buckets and slots arrays. Uses suggested capacity by finding next prime
            greater than or equal to capacity.
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IncreaseCapacity">
            <summary>
            Expand to new capacity. New capacity is next prime greater than or equal to suggested 
            size. This is called when the underlying array is filled. This performs no 
            defragmentation, allowing faster execution; note that this is reasonable since 
            AddIfNotPresent attempts to insert new elements in re-opened spots.
            </summary>
            <param name="sizeSuggestion"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.SetCapacity(System.Int32,System.Boolean)">
            <summary>
            Set the underlying buckets array to size newSize and rehash.  Note that newSize
            *must* be a prime.  It is very likely that you want to call IncreaseCapacity()
            instead of this method.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.AddIfNotPresent(`0)">
            <summary>
            Adds value to HashSet if not contained already
            Returns true if added and false if already present
            </summary>
            <param name="value">value to find</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.ContainsAllElements(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this contains of other's elements. Iterates over other's elements and 
            returns false as soon as it finds an element in other that's not in this.
            Used by SupersetOf, ProperSupersetOf, and SetEquals.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsSubsetOfHashSetWithSameEC(System.Collections.Generic.HashSet{`0})">
             <summary>
             Implementation Notes:
             If other is a hashset and is using same equality comparer, then checking subset is 
             faster. Simply check that each element in this is in other.
             
             Note: if other doesn't use same equality comparer, then Contains check is invalid,
             which is why callers must take are of this.
             
             If callers are concerned about whether this is a proper subset, they take care of that.
            
             </summary>
             <param name="other"></param>
             <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IntersectWithHashSetWithSameEC(System.Collections.Generic.HashSet{`0})">
            <summary>
            If other is a hashset that uses same equality comparer, intersect is much faster 
            because we can use other's Contains
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.InternalIndexOf(`0)">
            <summary>
            Used internally by set operations which have to rely on bit array marking. This is like
            Contains but returns index in slots array. 
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.SymmetricExceptWithUniqueHashSet(System.Collections.Generic.HashSet{`0})">
            <summary>
            if other is a set, we can assume it doesn't have duplicate elements, so use this
            technique: if can't remove, then it wasn't present in this set, so add.
            
            As with other methods, callers take care of ensuring that other is a hashset using the
            same equality comparer.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.AddOrGetLocation(`0,System.Int32@)">
            <summary>
            Add if not already in hashset. Returns an out param indicating index where added. This 
            is used by SymmetricExcept because it needs to know the following things:
            - whether the item was already present in the collection or added from other
            - where it's located (if already present, it will get marked for removal, otherwise
            marked for keeping)
            </summary>
            <param name="value"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.ToArray">
            <summary>
            Copies this to an array. Used for DebugView
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.HashSetEquals(System.Collections.Generic.HashSet{`0},System.Collections.Generic.HashSet{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Internal method used for HashSetEqualityComparer. Compares set1 and set2 according 
            to specified comparer.
            
            Because items are hashed according to a specific equality comparer, we have to resort
            to n^2 search if they're using different equality comparers.
            </summary>
            <param name="set1"></param>
            <param name="set2"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.AreEqualityComparersEqual(System.Collections.Generic.HashSet{`0},System.Collections.Generic.HashSet{`0})">
            <summary>
            Checks if equality comparers are equal. This is used for algorithms that can
            speed up if it knows the other item has unique elements. I.e. if they're using 
            different equality comparers, then uniqueness assumption between sets break.
            </summary>
            <param name="set1"></param>
            <param name="set2"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.InternalGetHashCode(`0)">
            <summary>
            Workaround Comparers that throw ArgumentNullException for GetHashCode(null).
            </summary>
            <param name="item"></param>
            <returns>hash code</returns>
        </member>
    </members>
</doc>
